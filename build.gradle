plugins {
	id 'java'
	id 'signing'
	id 'idea'
	id 'eclipse'
	id 'pmd'

	id 'com.diffplug.spotless' version '6.21.0'

	/* We have to use this 3rd party plugin for publishing to MavenCentral because as of AUG-2025 there is no official
	 * plugin which supports publishing to MavenCentral Portal. */
	id "com.vanniktech.maven.publish.base" version "0.36.0"
}

allprojects {
	apply plugin: 'com.diffplug.spotless'
	apply plugin: 'pmd'

	repositories {
		mavenCentral()
	}

	javadoc {
		options.tags = [
			"http.response.details:a:Http Response Details"
		]
	}

	java {
		sourceCompatibility = JavaVersion.VERSION_1_8
		targetCompatibility = JavaVersion.VERSION_1_8

		toolchain {
			languageVersion = JavaLanguageVersion.of(8)
		}
	}

	tasks.withType(JavaCompile).configureEach {
		options.encoding = 'UTF-8'
		options.release = 8 // enforce java 8 compatibility
	}

	spotless {
		groovyGradle {
			greclipse()

			trimTrailingWhitespace()
			indentWithTabs()
			endWithNewline()
		}
		format 'misc', {
			target '.gitattributes', '.gitignore'

			trimTrailingWhitespace()
			indentWithTabs()
			endWithNewline()
		}
		java {
			googleJavaFormat().aosp()

			removeUnusedImports()
			importOrder()
			formatAnnotations()
			trimTrailingWhitespace()
			indentWithTabs()
			endWithNewline()
		}
	}

	pmd {
		consoleOutput = true
		toolVersion = "7.12.0"

		// This tells PMD to use your custom ruleset file.
		ruleSetFiles = rootProject.files("config/pmd/pmd-ruleset.xml")

		// This is important: it prevents PMD from using its default rules.
		ruleSets = []
	}
}

def configureMavenCentralPublishing(Project project) {
	project.plugins.withId('com.vanniktech.maven.publish.base') {
		project.mavenPublishing {
			publishToMavenCentral(true) // publish automatically after upload to Maven Central
		}
	}
}

subprojects {
	apply plugin: 'java'
	apply plugin: 'idea'
	apply plugin: 'eclipse'

	group = 'cloud.stackit.sdk'

	// only apply to service sub-projects and core
	if (project.path.startsWith(':services:') || project.name == "core" ) {
		apply plugin: 'signing'
		apply plugin: 'com.vanniktech.maven.publish.base'

		// override the version of each service with the ones obtained from the VERSION files
		def versionFile = project.file("VERSION")
		if (versionFile.exists()) {
			try {
				version = versionFile.text.trim()
			} catch (IOException e) {
				version = 'SNAPSHOT'
				logger.error("Could not read VERSION file for project '${project.path}': ${e.message}")
			}
		} else {
			version = 'SNAPSHOT'
			logger.warn("VERSION file not found in project '${project.path}'. Skipping version setting.")
		}

		tasks.register('lintProjectVersion', VersionCheckTask) {}

		java {
			withSourcesJar()
			withJavadocJar()
		}

		// don't fail on missing javadoc strings
		tasks.withType(Javadoc).configureEach {
			options.addStringOption('Xdoclint:none', '-quiet')
		}

		publishing {
			publications {
				mavenJava(MavenPublication) {
					artifactId = "${project.name}"
					from components.java

					pom {
						name.set(project.name)
						description.set("STACKIT Java SDK for the ${project.name} service")
						url.set("https://github.com/stackitcloud/${rootProject.name}/tree/main/services/${project.name}")
						licenses {
							license {
								name.set("Apache License, Version 2.0")
								url.set("https://www.apache.org/licenses/LICENSE-2.0.txt")
							}
						}
						developers {
							developer {
								id.set("stackitcloud")
								name.set("STACKIT Developer Tools")
								email.set("developer-tools@stackit.cloud")
							}
						}
						scm {
							connection.set("scm:git:git://github.com/stackitcloud/${rootProject.name}.git")
							developerConnection.set("scm:git:ssh://github.com/stackitcloud/${rootProject.name}.git")
							url.set("https://github.com/stackitcloud/${rootProject.name}")
						}
					}
				}
			}

			repositories {
				mavenLocal()
			}
		}

		signing {
			required {
				// signing is only required if the artifacts are to be published to Maven Central
				gradle.taskGraph.hasTask(":services:${project.name}:publishToMavenCentral") || gradle.taskGraph.hasTask(":${project.name}:publishToMavenCentral")
			}

			def signingKey = System.getenv("GPG_SIGNING_KEY") ?: findProperty("signingKey")
			def signingPassword = System.getenv("GPG_SIGNING_PASSWORD") ?: findProperty("signingPassword")
			useInMemoryPgpKeys(signingKey as String, signingPassword as String)
			sign publishing.publications.mavenJava
		}

		configureMavenCentralPublishing(project)
	}

	// only apply to example sub-projects
	if (project.path.startsWith(':examples:')) {
		if (!project.hasProperty('mainClassName')) {
			logger.warn("'mainClassName' property not defined for subproject '${project.path}'. Skipping execution of this task.")
		}

		tasks.register('execute', JavaExec) {
			if (!project.hasProperty('mainClassName')) {
				doLast {
					logger.warn("'mainClassName' property not defined for subproject '${project.path}'. Skipping execution of this task.")
				}
				enabled = false // Disable the task if no main class is specified
				return
			}
			mainClass = project.mainClassName
			classpath = sourceSets.main.runtimeClasspath
		}
	}

	tasks.withType(Test).configureEach {
		// Enable JUnit 5 (Gradle 4.6+).
		useJUnitPlatform()

		// Always run tests, even when nothing changed.
		dependsOn 'cleanTest'

		// Show test results.
		testLogging {
			events "passed", "skipped", "failed"
		}
	}

	dependencies {
		if (project.path != ':core') {
			// prevent circular dependency
			implementation project(':core')
		}

		testImplementation 'org.junit.jupiter:junit-jupiter-api:5.13.3'
		testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.13.3'
		testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.12.2'
	}
}
