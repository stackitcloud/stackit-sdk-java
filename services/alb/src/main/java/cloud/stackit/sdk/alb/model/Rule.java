/*
 * STACKIT Application Load Balancer API
 * This API offers an interface to provision and manage Application Load Balancers in your STACKIT project.This solution offers modern L7 load balancing. Current features include TLS, path and prefix based routing aswell as routing based on headers, query parameters and keeping connections persistent with cookies and web sockets.  For each Application Load Balancer provided, two VMs are deployed in your STACKIT project and are subject to fees.
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package cloud.stackit.sdk.alb.model;

import cloud.stackit.sdk.alb.JSON;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/** Rule */
@javax.annotation.Generated(
		value = "org.openapitools.codegen.languages.JavaClientCodegen",
		comments = "Generator version: 7.19.0")
public class Rule {
	public static final String SERIALIZED_NAME_COOKIE_PERSISTENCE = "cookiePersistence";

	@SerializedName(SERIALIZED_NAME_COOKIE_PERSISTENCE)
	@javax.annotation.Nullable private CookiePersistence cookiePersistence;

	public static final String SERIALIZED_NAME_HEADERS = "headers";

	@SerializedName(SERIALIZED_NAME_HEADERS)
	@javax.annotation.Nullable private List<HttpHeader> headers = new ArrayList<>();

	public static final String SERIALIZED_NAME_PATH = "path";

	@SerializedName(SERIALIZED_NAME_PATH)
	@javax.annotation.Nullable private Path path;

	public static final String SERIALIZED_NAME_QUERY_PARAMETERS = "queryParameters";

	@SerializedName(SERIALIZED_NAME_QUERY_PARAMETERS)
	@javax.annotation.Nullable private List<QueryParameter> queryParameters = new ArrayList<>();

	public static final String SERIALIZED_NAME_TARGET_POOL = "targetPool";

	@SerializedName(SERIALIZED_NAME_TARGET_POOL)
	@javax.annotation.Nullable private String targetPool;

	public static final String SERIALIZED_NAME_WEB_SOCKET = "webSocket";

	@SerializedName(SERIALIZED_NAME_WEB_SOCKET)
	@javax.annotation.Nullable private Boolean webSocket;

	public Rule() {}

	public Rule cookiePersistence(@javax.annotation.Nullable CookiePersistence cookiePersistence) {
		this.cookiePersistence = cookiePersistence;
		return this;
	}

	/**
	 * Get cookiePersistence
	 *
	 * @return cookiePersistence
	 */
	@javax.annotation.Nullable public CookiePersistence getCookiePersistence() {
		return cookiePersistence;
	}

	public void setCookiePersistence(
			@javax.annotation.Nullable CookiePersistence cookiePersistence) {
		this.cookiePersistence = cookiePersistence;
	}

	public Rule headers(@javax.annotation.Nullable List<HttpHeader> headers) {
		this.headers = headers;
		return this;
	}

	public Rule addHeadersItem(HttpHeader headersItem) {
		if (this.headers == null) {
			this.headers = new ArrayList<>();
		}
		this.headers.add(headersItem);
		return this;
	}

	/**
	 * Headers for the rule.
	 *
	 * @return headers
	 */
	@javax.annotation.Nullable public List<HttpHeader> getHeaders() {
		return headers;
	}

	public void setHeaders(@javax.annotation.Nullable List<HttpHeader> headers) {
		this.headers = headers;
	}

	public Rule path(@javax.annotation.Nullable Path path) {
		this.path = path;
		return this;
	}

	/**
	 * Get path
	 *
	 * @return path
	 */
	@javax.annotation.Nullable public Path getPath() {
		return path;
	}

	public void setPath(@javax.annotation.Nullable Path path) {
		this.path = path;
	}

	public Rule queryParameters(@javax.annotation.Nullable List<QueryParameter> queryParameters) {
		this.queryParameters = queryParameters;
		return this;
	}

	public Rule addQueryParametersItem(QueryParameter queryParametersItem) {
		if (this.queryParameters == null) {
			this.queryParameters = new ArrayList<>();
		}
		this.queryParameters.add(queryParametersItem);
		return this;
	}

	/**
	 * Query parameters for the rule.
	 *
	 * @return queryParameters
	 */
	@javax.annotation.Nullable public List<QueryParameter> getQueryParameters() {
		return queryParameters;
	}

	public void setQueryParameters(
			@javax.annotation.Nullable List<QueryParameter> queryParameters) {
		this.queryParameters = queryParameters;
	}

	public Rule targetPool(@javax.annotation.Nullable String targetPool) {
		this.targetPool = targetPool;
		return this;
	}

	/**
	 * Reference target pool by target pool name.
	 *
	 * @return targetPool
	 */
	@javax.annotation.Nullable public String getTargetPool() {
		return targetPool;
	}

	public void setTargetPool(@javax.annotation.Nullable String targetPool) {
		this.targetPool = targetPool;
	}

	public Rule webSocket(@javax.annotation.Nullable Boolean webSocket) {
		this.webSocket = webSocket;
		return this;
	}

	/**
	 * If enabled, when client sends an HTTP request with and Upgrade header, indicating the desire
	 * to establish a Websocket connection, if backend server supports WebSocket, it responds with
	 * HTTP 101 status code, switching protocols from HTTP to WebSocket. Hence the client and the
	 * server can exchange data in real-time using one long-lived TCP connection.
	 *
	 * @return webSocket
	 */
	@javax.annotation.Nullable public Boolean getWebSocket() {
		return webSocket;
	}

	public void setWebSocket(@javax.annotation.Nullable Boolean webSocket) {
		this.webSocket = webSocket;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		Rule rule = (Rule) o;
		return Objects.equals(this.cookiePersistence, rule.cookiePersistence)
				&& Objects.equals(this.headers, rule.headers)
				&& Objects.equals(this.path, rule.path)
				&& Objects.equals(this.queryParameters, rule.queryParameters)
				&& Objects.equals(this.targetPool, rule.targetPool)
				&& Objects.equals(this.webSocket, rule.webSocket);
	}

	@Override
	public int hashCode() {
		return Objects.hash(
				cookiePersistence, headers, path, queryParameters, targetPool, webSocket);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class Rule {\n");
		sb.append("    cookiePersistence: ")
				.append(toIndentedString(cookiePersistence))
				.append("\n");
		sb.append("    headers: ").append(toIndentedString(headers)).append("\n");
		sb.append("    path: ").append(toIndentedString(path)).append("\n");
		sb.append("    queryParameters: ").append(toIndentedString(queryParameters)).append("\n");
		sb.append("    targetPool: ").append(toIndentedString(targetPool)).append("\n");
		sb.append("    webSocket: ").append(toIndentedString(webSocket)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces (except the first
	 * line).
	 */
	private String toIndentedString(Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

	public static HashSet<String> openapiFields;
	public static HashSet<String> openapiRequiredFields;

	static {
		// a set of all properties/fields (JSON key names)
		openapiFields =
				new HashSet<String>(
						Arrays.asList(
								"cookiePersistence",
								"headers",
								"path",
								"queryParameters",
								"targetPool",
								"webSocket"));

		// a set of required properties/fields (JSON key names)
		openapiRequiredFields = new HashSet<String>(0);
	}

	/**
	 * Validates the JSON Element and throws an exception if issues found
	 *
	 * @param jsonElement JSON Element
	 * @throws IOException if the JSON Element is invalid with respect to Rule
	 */
	public static void validateJsonElement(JsonElement jsonElement) throws IOException {
		if (jsonElement == null) {
			if (!Rule.openapiRequiredFields
					.isEmpty()) { // has required fields but JSON element is null
				throw new IllegalArgumentException(
						String.format(
								java.util.Locale.ROOT,
								"The required field(s) %s in Rule is not found in the empty JSON string",
								Rule.openapiRequiredFields.toString()));
			}
		}

		Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
		// check to see if the JSON string contains additional fields
		for (Map.Entry<String, JsonElement> entry : entries) {
			if (!Rule.openapiFields.contains(entry.getKey())) {
				throw new IllegalArgumentException(
						String.format(
								java.util.Locale.ROOT,
								"The field `%s` in the JSON string is not defined in the `Rule` properties. JSON: %s",
								entry.getKey(),
								jsonElement.toString()));
			}
		}
		JsonObject jsonObj = jsonElement.getAsJsonObject();
		// validate the optional field `cookiePersistence`
		if (jsonObj.get("cookiePersistence") != null
				&& !jsonObj.get("cookiePersistence").isJsonNull()) {
			CookiePersistence.validateJsonElement(jsonObj.get("cookiePersistence"));
		}
		if (jsonObj.get("headers") != null && !jsonObj.get("headers").isJsonNull()) {
			JsonArray jsonArrayheaders = jsonObj.getAsJsonArray("headers");
			if (jsonArrayheaders != null) {
				// ensure the json data is an array
				if (!jsonObj.get("headers").isJsonArray()) {
					throw new IllegalArgumentException(
							String.format(
									java.util.Locale.ROOT,
									"Expected the field `headers` to be an array in the JSON string but got `%s`",
									jsonObj.get("headers").toString()));
				}

				// validate the optional field `headers` (array)
				for (int i = 0; i < jsonArrayheaders.size(); i++) {
					HttpHeader.validateJsonElement(jsonArrayheaders.get(i));
				}
				;
			}
		}
		// validate the optional field `path`
		if (jsonObj.get("path") != null && !jsonObj.get("path").isJsonNull()) {
			Path.validateJsonElement(jsonObj.get("path"));
		}
		if (jsonObj.get("queryParameters") != null
				&& !jsonObj.get("queryParameters").isJsonNull()) {
			JsonArray jsonArrayqueryParameters = jsonObj.getAsJsonArray("queryParameters");
			if (jsonArrayqueryParameters != null) {
				// ensure the json data is an array
				if (!jsonObj.get("queryParameters").isJsonArray()) {
					throw new IllegalArgumentException(
							String.format(
									java.util.Locale.ROOT,
									"Expected the field `queryParameters` to be an array in the JSON string but got `%s`",
									jsonObj.get("queryParameters").toString()));
				}

				// validate the optional field `queryParameters` (array)
				for (int i = 0; i < jsonArrayqueryParameters.size(); i++) {
					QueryParameter.validateJsonElement(jsonArrayqueryParameters.get(i));
				}
				;
			}
		}
		if ((jsonObj.get("targetPool") != null && !jsonObj.get("targetPool").isJsonNull())
				&& !jsonObj.get("targetPool").isJsonPrimitive()) {
			throw new IllegalArgumentException(
					String.format(
							java.util.Locale.ROOT,
							"Expected the field `targetPool` to be a primitive type in the JSON string but got `%s`",
							jsonObj.get("targetPool").toString()));
		}
	}

	public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
		@SuppressWarnings("unchecked")
		@Override
		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
			if (!Rule.class.isAssignableFrom(type.getRawType())) {
				return null; // this class only serializes 'Rule' and its subtypes
			}
			final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
			final TypeAdapter<Rule> thisAdapter =
					gson.getDelegateAdapter(this, TypeToken.get(Rule.class));

			return (TypeAdapter<T>)
					new TypeAdapter<Rule>() {
						@Override
						public void write(JsonWriter out, Rule value) throws IOException {
							JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
							elementAdapter.write(out, obj);
						}

						@Override
						public Rule read(JsonReader in) throws IOException {
							JsonElement jsonElement = elementAdapter.read(in);
							validateJsonElement(jsonElement);
							return thisAdapter.fromJsonTree(jsonElement);
						}
					}.nullSafe();
		}
	}

	/**
	 * Create an instance of Rule given an JSON string
	 *
	 * @param jsonString JSON string
	 * @return An instance of Rule
	 * @throws IOException if the JSON string is invalid with respect to Rule
	 */
	public static Rule fromJson(String jsonString) throws IOException {
		return JSON.getGson().fromJson(jsonString, Rule.class);
	}

	/**
	 * Convert an instance of Rule to an JSON string
	 *
	 * @return JSON string
	 */
	public String toJson() {
		return JSON.getGson().toJson(this);
	}
}
