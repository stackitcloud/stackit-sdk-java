/*
 * STACKIT Network Load Balancer API
 * This API offers an interface to provision and manage load balancing servers in your STACKIT project. It also has the possibility of pooling target servers for load balancing purposes.  For each load balancer provided, two VMs are deployed in your OpenStack project subject to a fee.
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package cloud.stackit.sdk.loadbalancer.model;

import cloud.stackit.sdk.loadbalancer.JSON;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/** LoadBalancer */
@javax.annotation.Generated(
		value = "org.openapitools.codegen.languages.JavaClientCodegen",
		comments = "Generator version: 7.19.0")
public class LoadBalancer {
	public static final String SERIALIZED_NAME_DISABLE_TARGET_SECURITY_GROUP_ASSIGNMENT =
			"disableTargetSecurityGroupAssignment";

	@SerializedName(SERIALIZED_NAME_DISABLE_TARGET_SECURITY_GROUP_ASSIGNMENT)
	@javax.annotation.Nullable private Boolean disableTargetSecurityGroupAssignment;

	public static final String SERIALIZED_NAME_ERRORS = "errors";

	@SerializedName(SERIALIZED_NAME_ERRORS)
	@javax.annotation.Nullable private List<LoadBalancerError> errors = new ArrayList<>();

	public static final String SERIALIZED_NAME_EXTERNAL_ADDRESS = "externalAddress";

	@SerializedName(SERIALIZED_NAME_EXTERNAL_ADDRESS)
	@javax.annotation.Nullable private String externalAddress;

	public static final String SERIALIZED_NAME_LABELS = "labels";

	@SerializedName(SERIALIZED_NAME_LABELS)
	@javax.annotation.Nullable private Map<String, String> labels = new HashMap<>();

	public static final String SERIALIZED_NAME_LISTENERS = "listeners";

	@SerializedName(SERIALIZED_NAME_LISTENERS)
	@javax.annotation.Nullable private List<Listener> listeners = new ArrayList<>();

	public static final String SERIALIZED_NAME_LOAD_BALANCER_SECURITY_GROUP =
			"loadBalancerSecurityGroup";

	@SerializedName(SERIALIZED_NAME_LOAD_BALANCER_SECURITY_GROUP)
	@javax.annotation.Nullable private SecurityGroup loadBalancerSecurityGroup;

	public static final String SERIALIZED_NAME_NAME = "name";

	@SerializedName(SERIALIZED_NAME_NAME)
	@javax.annotation.Nullable private String name;

	public static final String SERIALIZED_NAME_NETWORKS = "networks";

	@SerializedName(SERIALIZED_NAME_NETWORKS)
	@javax.annotation.Nullable private List<Network> networks = new ArrayList<>();

	public static final String SERIALIZED_NAME_OPTIONS = "options";

	@SerializedName(SERIALIZED_NAME_OPTIONS)
	@javax.annotation.Nullable private LoadBalancerOptions options;

	public static final String SERIALIZED_NAME_PLAN_ID = "planId";

	@SerializedName(SERIALIZED_NAME_PLAN_ID)
	@javax.annotation.Nullable private String planId;

	public static final String SERIALIZED_NAME_PRIVATE_ADDRESS = "privateAddress";

	@SerializedName(SERIALIZED_NAME_PRIVATE_ADDRESS)
	@javax.annotation.Nullable private String privateAddress;

	public static final String SERIALIZED_NAME_REGION = "region";

	@SerializedName(SERIALIZED_NAME_REGION)
	@javax.annotation.Nullable private String region;

	/** Gets or Sets status */
	@JsonAdapter(StatusEnum.Adapter.class)
	public enum StatusEnum {
		STATUS_UNSPECIFIED("STATUS_UNSPECIFIED"),

		STATUS_PENDING("STATUS_PENDING"),

		STATUS_READY("STATUS_READY"),

		STATUS_ERROR("STATUS_ERROR"),

		STATUS_TERMINATING("STATUS_TERMINATING"),

		UNKNOWN_DEFAULT_OPEN_API("unknown_default_open_api");

		private String value;

		StatusEnum(String value) {
			this.value = value;
		}

		public String getValue() {
			return value;
		}

		@Override
		public String toString() {
			return String.valueOf(value);
		}

		public static StatusEnum fromValue(String value) {
			for (StatusEnum b : StatusEnum.values()) {
				if (b.value.equals(value)) {
					return b;
				}
			}
			return UNKNOWN_DEFAULT_OPEN_API;
		}

		public static class Adapter extends TypeAdapter<StatusEnum> {
			@Override
			public void write(final JsonWriter jsonWriter, final StatusEnum enumeration)
					throws IOException {
				jsonWriter.value(enumeration.getValue());
			}

			@Override
			public StatusEnum read(final JsonReader jsonReader) throws IOException {
				String value = jsonReader.nextString();
				return StatusEnum.fromValue(value);
			}
		}

		public static void validateJsonElement(JsonElement jsonElement) throws IOException {
			String value = jsonElement.getAsString();
			StatusEnum.fromValue(value);
		}
	}

	public static final String SERIALIZED_NAME_STATUS = "status";

	@SerializedName(SERIALIZED_NAME_STATUS)
	@javax.annotation.Nullable private StatusEnum status;

	public static final String SERIALIZED_NAME_TARGET_POOLS = "targetPools";

	@SerializedName(SERIALIZED_NAME_TARGET_POOLS)
	@javax.annotation.Nullable private List<TargetPool> targetPools = new ArrayList<>();

	public static final String SERIALIZED_NAME_TARGET_SECURITY_GROUP = "targetSecurityGroup";

	@SerializedName(SERIALIZED_NAME_TARGET_SECURITY_GROUP)
	@javax.annotation.Nullable private SecurityGroup targetSecurityGroup;

	public static final String SERIALIZED_NAME_VERSION = "version";

	@SerializedName(SERIALIZED_NAME_VERSION)
	@javax.annotation.Nullable private String version;

	public LoadBalancer() {}

	public LoadBalancer(
			List<LoadBalancerError> errors,
			SecurityGroup loadBalancerSecurityGroup,
			String privateAddress,
			String region,
			StatusEnum status,
			SecurityGroup targetSecurityGroup) {
		this();
		this.errors = errors;
		this.loadBalancerSecurityGroup = loadBalancerSecurityGroup;
		this.privateAddress = privateAddress;
		this.region = region;
		this.status = status;
		this.targetSecurityGroup = targetSecurityGroup;
	}

	public LoadBalancer disableTargetSecurityGroupAssignment(
			@javax.annotation.Nullable Boolean disableTargetSecurityGroupAssignment) {
		this.disableTargetSecurityGroupAssignment = disableTargetSecurityGroupAssignment;
		return this;
	}

	/**
	 * Disable target security group assignemt to allow targets outside of the given network.
	 * Connectivity to targets need to be ensured by the customer, including routing and Security
	 * Groups (targetSecurityGroup can be assigned). Not changeable after creation.
	 *
	 * @return disableTargetSecurityGroupAssignment
	 */
	@javax.annotation.Nullable public Boolean getDisableTargetSecurityGroupAssignment() {
		return disableTargetSecurityGroupAssignment;
	}

	public void setDisableTargetSecurityGroupAssignment(
			@javax.annotation.Nullable Boolean disableTargetSecurityGroupAssignment) {
		this.disableTargetSecurityGroupAssignment = disableTargetSecurityGroupAssignment;
	}

	/**
	 * Reports all errors a load balancer has.
	 *
	 * @return errors
	 */
	@javax.annotation.Nullable public List<LoadBalancerError> getErrors() {
		return errors;
	}

	public LoadBalancer externalAddress(@javax.annotation.Nullable String externalAddress) {
		this.externalAddress = externalAddress;
		return this;
	}

	/**
	 * External load balancer IP address where this load balancer is exposed. Not changeable after
	 * creation.
	 *
	 * @return externalAddress
	 */
	@javax.annotation.Nullable public String getExternalAddress() {
		return externalAddress;
	}

	public void setExternalAddress(@javax.annotation.Nullable String externalAddress) {
		this.externalAddress = externalAddress;
	}

	public LoadBalancer labels(@javax.annotation.Nullable Map<String, String> labels) {
		this.labels = labels;
		return this;
	}

	public LoadBalancer putLabelsItem(String key, String labelsItem) {
		if (this.labels == null) {
			this.labels = new HashMap<>();
		}
		this.labels.put(key, labelsItem);
		return this;
	}

	/**
	 * Labels represent user-defined metadata as key-value pairs. Label count should not exceed 64
	 * per LB. **Key Formatting Rules:** Length: 1-63 characters. Characters: Must begin and end
	 * with [a-zA-Z0-9]. May contain dashes (-), underscores (_), dots (.), and alphanumerics in
	 * between. Keys starting with &#39;stackit-&#39; are system-reserved; users MUST NOT manage
	 * them. **Value Formatting Rules:** Length: 0-63 characters (empty string explicitly allowed).
	 * Characters (for non-empty values): Must begin and end with [a-zA-Z0-9]. May contain dashes
	 * (-), underscores (_), dots (.), and alphanumerics in between.
	 *
	 * @return labels
	 */
	@javax.annotation.Nullable public Map<String, String> getLabels() {
		return labels;
	}

	public void setLabels(@javax.annotation.Nullable Map<String, String> labels) {
		this.labels = labels;
	}

	public LoadBalancer listeners(@javax.annotation.Nullable List<Listener> listeners) {
		this.listeners = listeners;
		return this;
	}

	public LoadBalancer addListenersItem(Listener listenersItem) {
		if (this.listeners == null) {
			this.listeners = new ArrayList<>();
		}
		this.listeners.add(listenersItem);
		return this;
	}

	/**
	 * There is a maximum listener count of 20. Port and protocol limitations: - UDP listeners
	 * cannot have the same port. - TCP-derived listeners cannot have the same port. A TCP-derived
	 * listener is any listener that listens on a TCP port. As of now those are: TCP, TCP_PROXY, and
	 * PROTOCOL_TLS_PASSTHROUGH. The only exception is, if all listeners for the same port are
	 * PROTOCOL_TLS_PASSTHROUGH. - PROTOCOL_TLS_PASSTHROUGH listeners cannot have the same port and
	 * at least one common domain name. - PROTOCOL_TLS_PASSTHROUGH listeners can have the same
	 * domain name and different ports though (e.g. ports 443 and 8443 for domain example.com). -
	 * PROTOCOL_TLS_PASSTHROUGH listeners without a domain name serve as a default listener and you
	 * can have only one default listener.
	 *
	 * @return listeners
	 */
	@javax.annotation.Nullable public List<Listener> getListeners() {
		return listeners;
	}

	public void setListeners(@javax.annotation.Nullable List<Listener> listeners) {
		this.listeners = listeners;
	}

	/**
	 * Security Group permitting network traffic from the LoadBalancer to the targets. Useful when
	 * disableTargetSecurityGroupAssignment&#x3D;true to manually assign target security groups to
	 * targets.
	 *
	 * @return loadBalancerSecurityGroup
	 */
	@javax.annotation.Nullable public SecurityGroup getLoadBalancerSecurityGroup() {
		return loadBalancerSecurityGroup;
	}

	public LoadBalancer name(@javax.annotation.Nullable String name) {
		this.name = name;
		return this;
	}

	/**
	 * Load balancer name. Not changeable after creation.
	 *
	 * @return name
	 */
	@javax.annotation.Nullable public String getName() {
		return name;
	}

	public void setName(@javax.annotation.Nullable String name) {
		this.name = name;
	}

	public LoadBalancer networks(@javax.annotation.Nullable List<Network> networks) {
		this.networks = networks;
		return this;
	}

	public LoadBalancer addNetworksItem(Network networksItem) {
		if (this.networks == null) {
			this.networks = new ArrayList<>();
		}
		this.networks.add(networksItem);
		return this;
	}

	/**
	 * List of networks that listeners and targets reside in. Currently limited to one. Not
	 * changeable after creation.
	 *
	 * @return networks
	 */
	@javax.annotation.Nullable public List<Network> getNetworks() {
		return networks;
	}

	public void setNetworks(@javax.annotation.Nullable List<Network> networks) {
		this.networks = networks;
	}

	public LoadBalancer options(@javax.annotation.Nullable LoadBalancerOptions options) {
		this.options = options;
		return this;
	}

	/**
	 * Get options
	 *
	 * @return options
	 */
	@javax.annotation.Nullable public LoadBalancerOptions getOptions() {
		return options;
	}

	public void setOptions(@javax.annotation.Nullable LoadBalancerOptions options) {
		this.options = options;
	}

	public LoadBalancer planId(@javax.annotation.Nullable String planId) {
		this.planId = planId;
		return this;
	}

	/**
	 * Service Plan configures the size of the Load Balancer. Currently supported plans are p10,
	 * p50, p250 and p750. This list can change in the future where plan ids will be removed and new
	 * plans by added. That is the reason this is not an enum.
	 *
	 * @return planId
	 */
	@javax.annotation.Nullable public String getPlanId() {
		return planId;
	}

	public void setPlanId(@javax.annotation.Nullable String planId) {
		this.planId = planId;
	}

	/**
	 * Transient private load balancer IP address that can change any time.
	 *
	 * @return privateAddress
	 */
	@javax.annotation.Nullable public String getPrivateAddress() {
		return privateAddress;
	}

	/**
	 * Region of the LoadBalancer
	 *
	 * @return region
	 */
	@javax.annotation.Nullable public String getRegion() {
		return region;
	}

	/**
	 * Get status
	 *
	 * @return status
	 */
	@javax.annotation.Nullable public StatusEnum getStatus() {
		return status;
	}

	public LoadBalancer targetPools(@javax.annotation.Nullable List<TargetPool> targetPools) {
		this.targetPools = targetPools;
		return this;
	}

	public LoadBalancer addTargetPoolsItem(TargetPool targetPoolsItem) {
		if (this.targetPools == null) {
			this.targetPools = new ArrayList<>();
		}
		this.targetPools.add(targetPoolsItem);
		return this;
	}

	/**
	 * List of all target pools which will be used in the load balancer. Limited to 20.
	 *
	 * @return targetPools
	 */
	@javax.annotation.Nullable public List<TargetPool> getTargetPools() {
		return targetPools;
	}

	public void setTargetPools(@javax.annotation.Nullable List<TargetPool> targetPools) {
		this.targetPools = targetPools;
	}

	/**
	 * Security Group that allows the targets to receive traffic from the LoadBalancer. Useful when
	 * disableTargetSecurityGroupAssignment&#x3D;true to manually assign target security groups to
	 * targets.
	 *
	 * @return targetSecurityGroup
	 */
	@javax.annotation.Nullable public SecurityGroup getTargetSecurityGroup() {
		return targetSecurityGroup;
	}

	public LoadBalancer version(@javax.annotation.Nullable String version) {
		this.version = version;
		return this;
	}

	/**
	 * Load balancer resource version. Must be empty or unset for creating load balancers, non-empty
	 * for updating load balancers. Semantics: While retrieving load balancers, this is the current
	 * version of this load balancer resource that changes during updates of the load balancers. On
	 * updates this field specified the load balancer version you calculated your update for instead
	 * of the future version to enable concurrency safe updates. Update calls will then report the
	 * new version in their result as you would see with a load balancer retrieval call later. There
	 * exist no total order of the version, so you can only compare it for equality, but not for
	 * less/greater than another version. Since the creation of load balancer is always intended to
	 * create the first version of it, there should be no existing version. That&#39;s why this
	 * field must by empty of not present in that case.
	 *
	 * @return version
	 */
	@javax.annotation.Nullable public String getVersion() {
		return version;
	}

	public void setVersion(@javax.annotation.Nullable String version) {
		this.version = version;
	}

	/**
	 * A container for additional, undeclared properties. This is a holder for any undeclared
	 * properties as specified with the 'additionalProperties' keyword in the OAS document.
	 */
	private Map<String, Object> additionalProperties;

	/**
	 * Set the additional (undeclared) property with the specified name and value. If the property
	 * does not already exist, create it otherwise replace it.
	 *
	 * @param key name of the property
	 * @param value value of the property
	 * @return the LoadBalancer instance itself
	 */
	public LoadBalancer putAdditionalProperty(String key, Object value) {
		if (this.additionalProperties == null) {
			this.additionalProperties = new HashMap<String, Object>();
		}
		this.additionalProperties.put(key, value);
		return this;
	}

	/**
	 * Return the additional (undeclared) property.
	 *
	 * @return a map of objects
	 */
	public Map<String, Object> getAdditionalProperties() {
		return additionalProperties;
	}

	/**
	 * Return the additional (undeclared) property with the specified name.
	 *
	 * @param key name of the property
	 * @return an object
	 */
	public Object getAdditionalProperty(String key) {
		if (this.additionalProperties == null) {
			return null;
		}
		return this.additionalProperties.get(key);
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		LoadBalancer loadBalancer = (LoadBalancer) o;
		return Objects.equals(
						this.disableTargetSecurityGroupAssignment,
						loadBalancer.disableTargetSecurityGroupAssignment)
				&& Objects.equals(this.errors, loadBalancer.errors)
				&& Objects.equals(this.externalAddress, loadBalancer.externalAddress)
				&& Objects.equals(this.labels, loadBalancer.labels)
				&& Objects.equals(this.listeners, loadBalancer.listeners)
				&& Objects.equals(
						this.loadBalancerSecurityGroup, loadBalancer.loadBalancerSecurityGroup)
				&& Objects.equals(this.name, loadBalancer.name)
				&& Objects.equals(this.networks, loadBalancer.networks)
				&& Objects.equals(this.options, loadBalancer.options)
				&& Objects.equals(this.planId, loadBalancer.planId)
				&& Objects.equals(this.privateAddress, loadBalancer.privateAddress)
				&& Objects.equals(this.region, loadBalancer.region)
				&& Objects.equals(this.status, loadBalancer.status)
				&& Objects.equals(this.targetPools, loadBalancer.targetPools)
				&& Objects.equals(this.targetSecurityGroup, loadBalancer.targetSecurityGroup)
				&& Objects.equals(this.version, loadBalancer.version)
				&& Objects.equals(this.additionalProperties, loadBalancer.additionalProperties);
	}

	@Override
	public int hashCode() {
		return Objects.hash(
				disableTargetSecurityGroupAssignment,
				errors,
				externalAddress,
				labels,
				listeners,
				loadBalancerSecurityGroup,
				name,
				networks,
				options,
				planId,
				privateAddress,
				region,
				status,
				targetPools,
				targetSecurityGroup,
				version,
				additionalProperties);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class LoadBalancer {\n");
		sb.append("    disableTargetSecurityGroupAssignment: ")
				.append(toIndentedString(disableTargetSecurityGroupAssignment))
				.append("\n");
		sb.append("    errors: ").append(toIndentedString(errors)).append("\n");
		sb.append("    externalAddress: ").append(toIndentedString(externalAddress)).append("\n");
		sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
		sb.append("    listeners: ").append(toIndentedString(listeners)).append("\n");
		sb.append("    loadBalancerSecurityGroup: ")
				.append(toIndentedString(loadBalancerSecurityGroup))
				.append("\n");
		sb.append("    name: ").append(toIndentedString(name)).append("\n");
		sb.append("    networks: ").append(toIndentedString(networks)).append("\n");
		sb.append("    options: ").append(toIndentedString(options)).append("\n");
		sb.append("    planId: ").append(toIndentedString(planId)).append("\n");
		sb.append("    privateAddress: ").append(toIndentedString(privateAddress)).append("\n");
		sb.append("    region: ").append(toIndentedString(region)).append("\n");
		sb.append("    status: ").append(toIndentedString(status)).append("\n");
		sb.append("    targetPools: ").append(toIndentedString(targetPools)).append("\n");
		sb.append("    targetSecurityGroup: ")
				.append(toIndentedString(targetSecurityGroup))
				.append("\n");
		sb.append("    version: ").append(toIndentedString(version)).append("\n");
		sb.append("    additionalProperties: ")
				.append(toIndentedString(additionalProperties))
				.append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces (except the first
	 * line).
	 */
	private String toIndentedString(Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

	public static HashSet<String> openapiFields;
	public static HashSet<String> openapiRequiredFields;

	static {
		// a set of all properties/fields (JSON key names)
		openapiFields =
				new HashSet<String>(
						Arrays.asList(
								"disableTargetSecurityGroupAssignment",
								"errors",
								"externalAddress",
								"labels",
								"listeners",
								"loadBalancerSecurityGroup",
								"name",
								"networks",
								"options",
								"planId",
								"privateAddress",
								"region",
								"status",
								"targetPools",
								"targetSecurityGroup",
								"version"));

		// a set of required properties/fields (JSON key names)
		openapiRequiredFields = new HashSet<String>(0);
	}

	/**
	 * Validates the JSON Element and throws an exception if issues found
	 *
	 * @param jsonElement JSON Element
	 * @throws IOException if the JSON Element is invalid with respect to LoadBalancer
	 */
	public static void validateJsonElement(JsonElement jsonElement) throws IOException {
		if (jsonElement == null) {
			if (!LoadBalancer.openapiRequiredFields
					.isEmpty()) { // has required fields but JSON element is null
				throw new IllegalArgumentException(
						String.format(
								java.util.Locale.ROOT,
								"The required field(s) %s in LoadBalancer is not found in the empty JSON string",
								LoadBalancer.openapiRequiredFields.toString()));
			}
		}
		JsonObject jsonObj = jsonElement.getAsJsonObject();
		if (jsonObj.get("errors") != null && !jsonObj.get("errors").isJsonNull()) {
			JsonArray jsonArrayerrors = jsonObj.getAsJsonArray("errors");
			if (jsonArrayerrors != null) {
				// ensure the json data is an array
				if (!jsonObj.get("errors").isJsonArray()) {
					throw new IllegalArgumentException(
							String.format(
									java.util.Locale.ROOT,
									"Expected the field `errors` to be an array in the JSON string but got `%s`",
									jsonObj.get("errors").toString()));
				}

				// validate the optional field `errors` (array)
				for (int i = 0; i < jsonArrayerrors.size(); i++) {
					LoadBalancerError.validateJsonElement(jsonArrayerrors.get(i));
				}
				;
			}
		}
		if ((jsonObj.get("externalAddress") != null && !jsonObj.get("externalAddress").isJsonNull())
				&& !jsonObj.get("externalAddress").isJsonPrimitive()) {
			throw new IllegalArgumentException(
					String.format(
							java.util.Locale.ROOT,
							"Expected the field `externalAddress` to be a primitive type in the JSON string but got `%s`",
							jsonObj.get("externalAddress").toString()));
		}
		if (jsonObj.get("listeners") != null && !jsonObj.get("listeners").isJsonNull()) {
			JsonArray jsonArraylisteners = jsonObj.getAsJsonArray("listeners");
			if (jsonArraylisteners != null) {
				// ensure the json data is an array
				if (!jsonObj.get("listeners").isJsonArray()) {
					throw new IllegalArgumentException(
							String.format(
									java.util.Locale.ROOT,
									"Expected the field `listeners` to be an array in the JSON string but got `%s`",
									jsonObj.get("listeners").toString()));
				}

				// validate the optional field `listeners` (array)
				for (int i = 0; i < jsonArraylisteners.size(); i++) {
					Listener.validateJsonElement(jsonArraylisteners.get(i));
				}
				;
			}
		}
		// validate the optional field `loadBalancerSecurityGroup`
		if (jsonObj.get("loadBalancerSecurityGroup") != null
				&& !jsonObj.get("loadBalancerSecurityGroup").isJsonNull()) {
			SecurityGroup.validateJsonElement(jsonObj.get("loadBalancerSecurityGroup"));
		}
		if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull())
				&& !jsonObj.get("name").isJsonPrimitive()) {
			throw new IllegalArgumentException(
					String.format(
							java.util.Locale.ROOT,
							"Expected the field `name` to be a primitive type in the JSON string but got `%s`",
							jsonObj.get("name").toString()));
		}
		if (jsonObj.get("networks") != null && !jsonObj.get("networks").isJsonNull()) {
			JsonArray jsonArraynetworks = jsonObj.getAsJsonArray("networks");
			if (jsonArraynetworks != null) {
				// ensure the json data is an array
				if (!jsonObj.get("networks").isJsonArray()) {
					throw new IllegalArgumentException(
							String.format(
									java.util.Locale.ROOT,
									"Expected the field `networks` to be an array in the JSON string but got `%s`",
									jsonObj.get("networks").toString()));
				}

				// validate the optional field `networks` (array)
				for (int i = 0; i < jsonArraynetworks.size(); i++) {
					Network.validateJsonElement(jsonArraynetworks.get(i));
				}
				;
			}
		}
		// validate the optional field `options`
		if (jsonObj.get("options") != null && !jsonObj.get("options").isJsonNull()) {
			LoadBalancerOptions.validateJsonElement(jsonObj.get("options"));
		}
		if ((jsonObj.get("planId") != null && !jsonObj.get("planId").isJsonNull())
				&& !jsonObj.get("planId").isJsonPrimitive()) {
			throw new IllegalArgumentException(
					String.format(
							java.util.Locale.ROOT,
							"Expected the field `planId` to be a primitive type in the JSON string but got `%s`",
							jsonObj.get("planId").toString()));
		}
		if ((jsonObj.get("privateAddress") != null && !jsonObj.get("privateAddress").isJsonNull())
				&& !jsonObj.get("privateAddress").isJsonPrimitive()) {
			throw new IllegalArgumentException(
					String.format(
							java.util.Locale.ROOT,
							"Expected the field `privateAddress` to be a primitive type in the JSON string but got `%s`",
							jsonObj.get("privateAddress").toString()));
		}
		if ((jsonObj.get("region") != null && !jsonObj.get("region").isJsonNull())
				&& !jsonObj.get("region").isJsonPrimitive()) {
			throw new IllegalArgumentException(
					String.format(
							java.util.Locale.ROOT,
							"Expected the field `region` to be a primitive type in the JSON string but got `%s`",
							jsonObj.get("region").toString()));
		}
		if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull())
				&& !jsonObj.get("status").isJsonPrimitive()) {
			throw new IllegalArgumentException(
					String.format(
							java.util.Locale.ROOT,
							"Expected the field `status` to be a primitive type in the JSON string but got `%s`",
							jsonObj.get("status").toString()));
		}
		// validate the optional field `status`
		if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
			StatusEnum.validateJsonElement(jsonObj.get("status"));
		}
		if (jsonObj.get("targetPools") != null && !jsonObj.get("targetPools").isJsonNull()) {
			JsonArray jsonArraytargetPools = jsonObj.getAsJsonArray("targetPools");
			if (jsonArraytargetPools != null) {
				// ensure the json data is an array
				if (!jsonObj.get("targetPools").isJsonArray()) {
					throw new IllegalArgumentException(
							String.format(
									java.util.Locale.ROOT,
									"Expected the field `targetPools` to be an array in the JSON string but got `%s`",
									jsonObj.get("targetPools").toString()));
				}

				// validate the optional field `targetPools` (array)
				for (int i = 0; i < jsonArraytargetPools.size(); i++) {
					TargetPool.validateJsonElement(jsonArraytargetPools.get(i));
				}
				;
			}
		}
		// validate the optional field `targetSecurityGroup`
		if (jsonObj.get("targetSecurityGroup") != null
				&& !jsonObj.get("targetSecurityGroup").isJsonNull()) {
			SecurityGroup.validateJsonElement(jsonObj.get("targetSecurityGroup"));
		}
		if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull())
				&& !jsonObj.get("version").isJsonPrimitive()) {
			throw new IllegalArgumentException(
					String.format(
							java.util.Locale.ROOT,
							"Expected the field `version` to be a primitive type in the JSON string but got `%s`",
							jsonObj.get("version").toString()));
		}
	}

	public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
		@SuppressWarnings("unchecked")
		@Override
		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
			if (!LoadBalancer.class.isAssignableFrom(type.getRawType())) {
				return null; // this class only serializes 'LoadBalancer' and its subtypes
			}
			final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
			final TypeAdapter<LoadBalancer> thisAdapter =
					gson.getDelegateAdapter(this, TypeToken.get(LoadBalancer.class));

			return (TypeAdapter<T>)
					new TypeAdapter<LoadBalancer>() {
						@Override
						public void write(JsonWriter out, LoadBalancer value) throws IOException {
							JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
							obj.remove("additionalProperties");
							// serialize additional properties
							if (value.getAdditionalProperties() != null) {
								for (Map.Entry<String, Object> entry :
										value.getAdditionalProperties().entrySet()) {
									if (entry.getValue() instanceof String)
										obj.addProperty(entry.getKey(), (String) entry.getValue());
									else if (entry.getValue() instanceof Number)
										obj.addProperty(entry.getKey(), (Number) entry.getValue());
									else if (entry.getValue() instanceof Boolean)
										obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
									else if (entry.getValue() instanceof Character)
										obj.addProperty(
												entry.getKey(), (Character) entry.getValue());
									else {
										JsonElement jsonElement = gson.toJsonTree(entry.getValue());
										if (jsonElement.isJsonArray()) {
											obj.add(entry.getKey(), jsonElement.getAsJsonArray());
										} else {
											obj.add(entry.getKey(), jsonElement.getAsJsonObject());
										}
									}
								}
							}
							elementAdapter.write(out, obj);
						}

						@Override
						public LoadBalancer read(JsonReader in) throws IOException {
							JsonElement jsonElement = elementAdapter.read(in);
							validateJsonElement(jsonElement);
							JsonObject jsonObj = jsonElement.getAsJsonObject();
							// store additional fields in the deserialized instance
							LoadBalancer instance = thisAdapter.fromJsonTree(jsonObj);
							for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
								if (!openapiFields.contains(entry.getKey())) {
									if (entry.getValue().isJsonPrimitive()) { // primitive type
										if (entry.getValue().getAsJsonPrimitive().isString())
											instance.putAdditionalProperty(
													entry.getKey(), entry.getValue().getAsString());
										else if (entry.getValue().getAsJsonPrimitive().isNumber())
											instance.putAdditionalProperty(
													entry.getKey(), entry.getValue().getAsNumber());
										else if (entry.getValue().getAsJsonPrimitive().isBoolean())
											instance.putAdditionalProperty(
													entry.getKey(),
													entry.getValue().getAsBoolean());
										else
											throw new IllegalArgumentException(
													String.format(
															java.util.Locale.ROOT,
															"The field `%s` has unknown primitive type. Value: %s",
															entry.getKey(),
															entry.getValue().toString()));
									} else if (entry.getValue().isJsonArray()) {
										instance.putAdditionalProperty(
												entry.getKey(),
												gson.fromJson(entry.getValue(), List.class));
									} else { // JSON object
										instance.putAdditionalProperty(
												entry.getKey(),
												gson.fromJson(entry.getValue(), HashMap.class));
									}
								}
							}
							return instance;
						}
					}.nullSafe();
		}
	}

	/**
	 * Create an instance of LoadBalancer given an JSON string
	 *
	 * @param jsonString JSON string
	 * @return An instance of LoadBalancer
	 * @throws IOException if the JSON string is invalid with respect to LoadBalancer
	 */
	public static LoadBalancer fromJson(String jsonString) throws IOException {
		return JSON.getGson().fromJson(jsonString, LoadBalancer.class);
	}

	/**
	 * Convert an instance of LoadBalancer to an JSON string
	 *
	 * @return JSON string
	 */
	public String toJson() {
		return JSON.getGson().toJson(this);
	}
}
