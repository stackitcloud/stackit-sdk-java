/*
 * STACKIT Network Load Balancer API
 * This API offers an interface to provision and manage load balancing servers in your STACKIT project. It also has the possibility of pooling target servers for load balancing purposes.  For each load balancer provided, two VMs are deployed in your OpenStack project subject to a fee.
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package cloud.stackit.sdk.loadbalancer.model;

import cloud.stackit.sdk.loadbalancer.JSON;
import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/**
 * The &#x60;Status&#x60; type defines a logical error model that is suitable for different
 * programming environments, including REST APIs and RPC APIs. It is used by
 * [gRPC](https://github.com/grpc). Each &#x60;Status&#x60; message contains three pieces of data:
 * error code, error message, and error details. You can find out more about this error model and
 * how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
 */
@javax.annotation.Generated(
		value = "org.openapitools.codegen.languages.JavaClientCodegen",
		comments = "Generator version: 7.15.0")
public class Status {
	public static final String SERIALIZED_NAME_CODE = "code";

	@SerializedName(SERIALIZED_NAME_CODE)
	@javax.annotation.Nullable private Integer code;

	public static final String SERIALIZED_NAME_DETAILS = "details";

	@SerializedName(SERIALIZED_NAME_DETAILS)
	@javax.annotation.Nullable private List<GoogleProtobufAny> details = new ArrayList<>();

	public static final String SERIALIZED_NAME_MESSAGE = "message";

	@SerializedName(SERIALIZED_NAME_MESSAGE)
	@javax.annotation.Nullable private String message;

	public Status() {}

	public Status code(@javax.annotation.Nullable Integer code) {
		this.code = code;
		return this;
	}

	/**
	 * The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	 *
	 * @return code
	 */
	@javax.annotation.Nullable public Integer getCode() {
		return code;
	}

	public void setCode(@javax.annotation.Nullable Integer code) {
		this.code = code;
	}

	public Status details(@javax.annotation.Nullable List<GoogleProtobufAny> details) {
		this.details = details;
		return this;
	}

	public Status addDetailsItem(GoogleProtobufAny detailsItem) {
		if (this.details == null) {
			this.details = new ArrayList<>();
		}
		this.details.add(detailsItem);
		return this;
	}

	/**
	 * A list of messages that carry the error details. There is a common set of message types for
	 * APIs to use.
	 *
	 * @return details
	 */
	@javax.annotation.Nullable public List<GoogleProtobufAny> getDetails() {
		return details;
	}

	public void setDetails(@javax.annotation.Nullable List<GoogleProtobufAny> details) {
		this.details = details;
	}

	public Status message(@javax.annotation.Nullable String message) {
		this.message = message;
		return this;
	}

	/**
	 * A developer-facing error message, which should be in English. Any user-facing error message
	 * should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details]
	 * field, or localized by the client.
	 *
	 * @return message
	 */
	@javax.annotation.Nullable public String getMessage() {
		return message;
	}

	public void setMessage(@javax.annotation.Nullable String message) {
		this.message = message;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		Status status = (Status) o;
		return Objects.equals(this.code, status.code)
				&& Objects.equals(this.details, status.details)
				&& Objects.equals(this.message, status.message);
	}

	@Override
	public int hashCode() {
		return Objects.hash(code, details, message);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class Status {\n");
		sb.append("    code: ").append(toIndentedString(code)).append("\n");
		sb.append("    details: ").append(toIndentedString(details)).append("\n");
		sb.append("    message: ").append(toIndentedString(message)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces (except the first
	 * line).
	 */
	private String toIndentedString(Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

	public static HashSet<String> openapiFields;
	public static HashSet<String> openapiRequiredFields;

	static {
		// a set of all properties/fields (JSON key names)
		openapiFields = new HashSet<String>(Arrays.asList("code", "details", "message"));

		// a set of required properties/fields (JSON key names)
		openapiRequiredFields = new HashSet<String>(0);
	}

	/**
	 * Validates the JSON Element and throws an exception if issues found
	 *
	 * @param jsonElement JSON Element
	 * @throws IOException if the JSON Element is invalid with respect to Status
	 */
	public static void validateJsonElement(JsonElement jsonElement) throws IOException {
		if (jsonElement == null) {
			if (!Status.openapiRequiredFields
					.isEmpty()) { // has required fields but JSON element is null
				throw new IllegalArgumentException(
						String.format(
								"The required field(s) %s in Status is not found in the empty JSON string",
								Status.openapiRequiredFields.toString()));
			}
		}

		Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
		// check to see if the JSON string contains additional fields
		for (Map.Entry<String, JsonElement> entry : entries) {
			if (!Status.openapiFields.contains(entry.getKey())) {
				throw new IllegalArgumentException(
						String.format(
								"The field `%s` in the JSON string is not defined in the `Status` properties. JSON: %s",
								entry.getKey(), jsonElement.toString()));
			}
		}
		JsonObject jsonObj = jsonElement.getAsJsonObject();
		// ensure the optional json data is an array if present
		if (jsonObj.get("details") != null
				&& !jsonObj.get("details").isJsonNull()
				&& !jsonObj.get("details").isJsonArray()) {
			throw new IllegalArgumentException(
					String.format(
							"Expected the field `details` to be an array in the JSON string but got `%s`",
							jsonObj.get("details").toString()));
		}
		if ((jsonObj.get("message") != null && !jsonObj.get("message").isJsonNull())
				&& !jsonObj.get("message").isJsonPrimitive()) {
			throw new IllegalArgumentException(
					String.format(
							"Expected the field `message` to be a primitive type in the JSON string but got `%s`",
							jsonObj.get("message").toString()));
		}
	}

	public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
		@SuppressWarnings("unchecked")
		@Override
		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
			if (!Status.class.isAssignableFrom(type.getRawType())) {
				return null; // this class only serializes 'Status' and its subtypes
			}
			final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
			final TypeAdapter<Status> thisAdapter =
					gson.getDelegateAdapter(this, TypeToken.get(Status.class));

			return (TypeAdapter<T>)
					new TypeAdapter<Status>() {
						@Override
						public void write(JsonWriter out, Status value) throws IOException {
							JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
							elementAdapter.write(out, obj);
						}

						@Override
						public Status read(JsonReader in) throws IOException {
							JsonElement jsonElement = elementAdapter.read(in);
							validateJsonElement(jsonElement);
							return thisAdapter.fromJsonTree(jsonElement);
						}
					}.nullSafe();
		}
	}

	/**
	 * Create an instance of Status given an JSON string
	 *
	 * @param jsonString JSON string
	 * @return An instance of Status
	 * @throws IOException if the JSON string is invalid with respect to Status
	 */
	public static Status fromJson(String jsonString) throws IOException {
		return JSON.getGson().fromJson(jsonString, Status.class);
	}

	/**
	 * Convert an instance of Status to an JSON string
	 *
	 * @return JSON string
	 */
	public String toJson() {
		return JSON.getGson().toJson(this);
	}
}
